<!DOCTYPE html>
<!-- This is based on DillingerLee's great template here:
https://github.com/Team-Code/KA_Offline -->
<html> 
 <head>
    <title>Processing.JS inside Webpages: Template</title> 
</head>
 <body>
    <p align="center"> 
	<!--This draws the Canvas on the webpage -->
      <canvas id="mycanvas"></canvas> 
    </p>
 </body>
 
 <!-- Run all the JavaScript stuff -->
 <!-- Include the processing.js library -->
 <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
 <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
 
 <script>
    var sketchProc = function(processingInstance) {
     with (processingInstance) {
        size(400, 400); 
        frameRate(30);
        
        // ProgramCodeGoesHere
        //Siddharth Narayanan - Fianl Project
//Angles in radians
// 

frameRate(20);
angleMode = "radians";
var mountainposition =0;
var page = "logo";
var textangle = 0;
var textangle1 = 0;
var textangle2 = 0;
var textangle3 = 0;
var textangle4 = 0;
var textangle5 = 0;
var bkgnd = [60, 160, 130];
var pos = 0;
var night = true;
var init = true;
var hinder;
var hinder2;
var hinder3;
var hinder4;

var keyState = [];
keyPressed = function(){
    keyState[keyCode] = true;
};
keyReleased = function(){
    keyState[keyCode] = false;
};


var drawCloud = function() {
    background(186, 184, 186);
};

var drawRoad = function() {
     strokeWeight(1);
     noStroke();
     fill(38, 105, 9);
ellipse(width/2,height,width*3,height*0.55);
noFill();
        stroke(46, 32, 15,100);

    bezier(width*0.85, height, width*0.45, height*0.75, width*0.8, height*0.9, width*0.28, height*0.73);
    bezier(width*0.3, height, width*0.35, height*0.75, width*0.36, height*0.78, width*0.25, height*0.73);
    
};

var drawSun = function() {
    
    noStroke();
    for (var c = 0; c < 10 ; c+=1){
        var from = color(201, 181, 158,1);
        var to = color(224, 158, 25);
        fill(lerpColor(from, to, c*0.1));
        ellipse (pos,70,100-c*10,100-c*9);
    }
    fill(245, 124, 17,70);
    noStroke();
    ellipse(pos,70,40,40);
};

var drawMoon = function() {
    
    noStroke();
    for (var c = 0; c < 10 ; c+=1){
        var from = color(201, 181, 158,1);
        var to = color(255, 255, 255,100);
        fill(lerpColor(from, to, c*0.1));
        ellipse (pos,50,100-c*10,100-c*9);
    }
    fill(255, 255, 255,180);
    noStroke();
    ellipse(pos,50,40,40);
};

var drawRange = function() {
    var incAmount = 0.01;
    for (var t = 0; t < incAmount*width; t += incAmount) {         var n = noise(t,t,t);
        var y = map(n, 0, 1, 0, height/2);
        stroke(133, 171, 21);
        rect(t*100, height-y-140, 1, y+60);
    }
    for (var t = 0; t < incAmount*width; t += incAmount) {
        var n = noise(t,t);
        var r = random(0,1);
        var y = map(n, 0, 1, 0, height/2);
        stroke(59, 110, 20);
        rect(t*100, height-y-80-r*3, 1, y+80);
    }
    for (var t = 0; t < incAmount*width; t += incAmount) {
        var n = noise(t,t,t);
        stroke(28, 71, 6);
        var r = random(0,1);
        var y = map(n, 0, 1, 0, height/1.7);
        rect(t*100, height-y-5*r, 1, y+20);
    }
    
    

};


//Create Rounded Triangle Function
var roundTri = function(ax, ay, bx, by, cx, cy,
  curvatureRadius) {
    var ab = dist(ax, ay, bx, by);
    var bc = dist(bx, by, cx, cy);
    var ac = dist(ax, ay, cx, cy);
    if (curvatureRadius <= 0 || ab === 0 || bc === 0 || ac === 0) {triangle(ax, ay, bx, by, cx, cy);
        return;}
    var p = [];
    p.push({temp: ax, y: ay, next_dist: ab, dx: bx - ax, dy: by - ay, next_x: 0, next_y: 0, prev_x: 0, prev_y: 0});
    p.push({ temp: bx, y: by, next_dist: bc,
        dx: cx - bx, dy: cy - by });
    p.push({ temp: cx, y: cy, next_dist: ac,
        dx: ax - cx, dy: ay - cy });
    var triVertex = function(A) {
        var d;
        var C = (A + 2) % 3;
        var theta = atan2(p[A].dy, p[A].dx);
        var gamma = atan2(-p[C].dy, -p[C].dx);
        var alpha = (gamma - theta);
        alpha /= 2;
        var i = abs(curvatureRadius / sin(alpha));
        d = p[A].next_dist;
        p[A].next_x = p[A].temp + i/d * p[A].dx;
        p[A].next_y = p[A].y + i/d * p[A].dy;
        d = p[C].next_dist;
        p[A].prev_x = p[A].temp - i/d * p[C].dx;
        p[A].prev_y = p[A].y - i/d * p[C].dy;
    };
    beginShape();
    for (var i = 0; i < p.length; i++) {
        triVertex(i);
        vertex(p[i].prev_x, p[i].prev_y);
        bezierVertex(p[i].temp, p[i].y, p[i].temp, p[i].y,
            p[i].next_x, p[i].next_y);
    }
    endShape(CLOSE);
};


//Create Objects
var Grid = function(){
    this.tileWidth = 200;
    this.rows = 25;
    this.columns = 18;
    this.horizon = 80;
    this.persp = 600;
    this.colorDk = [38, 105, 15];
    this.colorLt = [38, 105, 15];
    this.visibility = 200;
};
var grid = new Grid();

var Player = function(){
 this.x = width/2;
    this.y = height*0.7;
    this.color = [100, 86, 80];
    this.size = 4;
    this.turnSpeed = 2;
    this.theta = 0;
    this.jumpTheta = 0;
    this.jumper = 0.001;
    this.fC = 0;
    this.angle = 0;
    this.jumping = 0;
    this.zStart = -10 + grid.persp * 0.4 - grid.horizon * 0.1;
    this.position = new PVector((grid.columns + 1)/2 * grid.tileWidth, 0, 0);
    this.height = 120 - grid.horizon * 0.33;
    this.wall = [];
    this.corner = 999;
    this.turn = 0;
    this.rabbits = 0;
    this.points = 0;
    this.combo = false;
    this.start = 0;
};
var player = new Player();

Player.prototype.engine = function(theta){
    var radius = 150;
    //Right/Back
    this.dotX = width/2 + radius*cos(theta);
    this.dotY = height/2 + radius*sin(theta);
    //Left
    this.dotXL = width/2 + radius*cos(theta + 0.8*PI);
    this.dotYL = height/2 + radius*sin(theta + 0.8*PI);
    //Front
    this.dotXF = width/2 + radius*cos(this.jumpTheta*2+PI/4);
    this.dotYF = height/2 + radius*sin(this.jumpTheta*2+PI/4);
    //Tail   
    this.tailx = width/2 + radius*cos(this.theta);
    this.taily = height/2 + radius*sin(this.theta);
    //Updates    
    theta += this.speed;
    this.theta += this.speed/10;
    if(this.theta > 2*PI){
        this.theta = 0;
    }
    this.jumpTheta += this.speed;
    this.jumpTheta %= 2*PI;
};

//Create Tiger Parts
Player.prototype.shadow = function(engine, shade, sit){
    noStroke();
    fill(0, 0, 0, 5 + shade);
    if(!sit){
        roundTri(0, this.position.y/5 + 1, -15 + engine, this.position.y/5 + 26, 15-engine, this.position.y/5 + 26, 13);
    } else {ellipse(0, 21, 26, 11);
    
    
    }
};

Player.prototype.head = function(engine1, engine2, trot, jump, size, color, y2, w){
    noStroke();
    if(w){
        stroke(230, 135, 143);
        strokeWeight(0.3);
        ellipse(w * 3 - 3, 2, 3, 2);
        noStroke();
        roundTri(2, -8, 7 + w * 0.9, 1, 1, 6, 4.5);
    }
    fill(this.color[0]-5-color, this.color[1]-5-color, this.color[2]-5-color);
    fill(255,128,0);
    //ellipse(trot + engine1 + w/3, -0.5 + trot - jump * 0.6 + engine2 + y2, 14 - size - w/7, 13 - size - 1);
    beginShape();
    vertex(trot + engine1 + w/3, -0.5 + trot - jump * 0.6 + engine2 + y2-6);
    vertex(trot + engine1 + w/3-8, -0.5 + trot - jump * 0.6 + engine2 + y2-4);
    vertex(trot + engine1 + w/3-5, -0.5 + trot - jump * 0.6 + engine2 + y2+3);
     vertex(trot + engine1 + w/3+5, -0.5 + trot - jump * 0.6 + engine2 + y2+3);
    vertex(trot + engine1 + w/3+8, -0.5 + trot - jump * 0.6 + engine2 + y2-4);
   
    endShape();
    
    //Left ear
    roundTri(-7 + trot + engine1 + (y2 * 0.1) + w/2 + (w? 3:0), -9 + jump + engine2 + (y2 * 0.75) + w/6 - (w?1.5:0), -6 + trot/3 + engine1 + jump - (y2 * 0.1) + w * 0.7, -1 + trot * 2/3 + engine2 + (y2), 2 + trot * 2 + engine1 + jump, -4.6 + trot * 2/3 + jump + engine2 + (y2 * 0.9), 0);
    //Right ear
    roundTri(7 + trot + engine1 - (y2 * 0.1) - w/4 + (w? 1:0), -9 + jump + engine2 + (y2 * 0.73) - w * 0.6 + (w?2:0), 6 + trot * 4/3 + engine1 - jump - w/4, -1 + trot * 2/3 + engine2 + (y2 * 1.1), -2 + trot/3 + engine1 - jump - (y2 * 0.1) + w/2, -4.6 + trot * 2/3 + jump + engine2 + (y2), 0); 

    fill(148, 74, 59,250);
    // right blades
    beginShape();
    vertex(trot + engine1 + w/3+6.1, -0.5 + trot - jump * 0.6 + engine2 + y2+0.5);
    vertex(trot + engine1 + w/3+5.6, -0.5 + trot - jump * 0.6 + engine2 + y2+1.5);
    vertex(trot + engine1 + w/3+3.5, -0.5 + trot - jump * 0.6 + engine2 + y2-1);
    endShape();
    beginShape();
    vertex(trot + engine1 + w/3+7.5, -0.5 + trot - jump * 0.6 + engine2 + y2-2.75);
    vertex(trot + engine1 + w/3+7, -0.5 + trot - jump * 0.6 + engine2 + y2-1.5);
    vertex(trot + engine1 + w/3+5, -0.5 + trot - jump * 0.6 + engine2 + y2-4);
    endShape();
    beginShape();
    vertex(trot + engine1 + w/3+7, -0.5 + trot - jump * 0.6 + engine2 + y2-1);
    vertex(trot + engine1 + w/3+6.5, -0.5 + trot - jump * 0.6 + engine2 + y2+0);
    vertex(trot + engine1 + w/3+4, -0.5 + trot - jump * 0.6 + engine2 + y2-2.5);
    endShape();
    fill(148, 74, 59,250);
    // left blades
    beginShape();
    vertex(trot + engine1 + w/3-6.1, -0.5 + trot - jump * 0.6 + engine2 + y2+0.5);
    vertex(trot + engine1 + w/3-5.6, -0.5 + trot - jump * 0.6 + engine2 + y2+1.5);
    vertex(trot + engine1 + w/3-3.5, -0.5 + trot - jump * 0.6 + engine2 + y2-1);
    endShape();
    beginShape();
    vertex(trot + engine1 + w/3-7.5, -0.5 + trot - jump * 0.6 + engine2 + y2-2.75);
    vertex(trot + engine1 + w/3-7, -0.5 + trot - jump * 0.6 + engine2 + y2-1.5);
    vertex(trot + engine1 + w/3-5, -0.5 + trot - jump * 0.6 + engine2 + y2-4);
    endShape();
    beginShape();
    vertex(trot + engine1 + w/3-7, -0.5 + trot - jump * 0.6 + engine2 + y2-1);
    vertex(trot + engine1 + w/3-6.5, -0.5 + trot - jump * 0.6 + engine2 + y2+0);
    vertex(trot + engine1 + w/3-4, -0.5 + trot - jump * 0.6 + engine2 + y2-2.5);
    endShape();
    fill(59, 34, 25,250);
    // top blades
    beginShape();
    vertex(trot + engine1 + w/3, -0.5 + trot - jump * 0.6 + engine2 + y2-7);
    vertex(trot + engine1 + w/3-0.6, -0.5 + trot - jump * 0.6 + engine2 + y2-6);
    vertex(trot + engine1 + w/3, -0.5 + trot - jump * 0.6 + engine2 + y2);
    vertex(trot + engine1 + w/3+0.6, -0.5 + trot - jump * 0.6 + engine2 + y2-6);
    endShape();
};


    

Player.prototype.TigerFrontLegs = function(engine1, engine2, x, y, jump, color, top, w){
    //fill(this.color[0]-color, this.color[1]-color, this.color[2]-color);
    fill(255,128,0);
    //Paws
    ellipse(-x+2, y + jump - engine2-2, 4 - w * 5, 5);
    ellipse(x-2, y + jump - engine2-2, 5 + w/3, 5 - w/2);
    if(w){
        quad(x - engine1 * 0.07, y - engine2, x + 2.7 - engine1 * 0.03, y - engine2, x + 3 - engine1 * 0.1, y - engine2 + 14, x - 1 - engine1 * 0.1, y - engine2 + 12);
        ellipse(x * 0.7 + 2.6, y - engine2 * 0.1 - 2, 6 - engine1/10, 4 + engine2);
    }
    if(!top){
    //Left Toes
    fill(this.color[0]+color+35, this.color[1]+color-10, this.color[2]+color-15);
    fill(107, 86, 48);
    ellipse(-x, y + 0.2 + jump - engine1 * 0.6-2, 3, 1);
    ellipse(-x, y + 2 + jump - engine1-2, 1.2, 0.8);
    ellipse(-x + 1.2, y + 1.6 + jump - engine1-2, 1.2, 0.8);
    ellipse(-x - 1.2, y + 1.6 + jump - engine1-2, 1.2, 0.8);
    //Right Toes
    ellipse(x, y + 0.2 + jump - engine2 * 0.6-2, 3, 1);
    ellipse(x, y + 2 + jump - engine2-2, 1.2, 0.8);
    ellipse(x - 1.2, y + 1.6 + jump - engine2-2, 1.2, 0.8);
    ellipse(x + 1.2, y + 1.6 + jump - engine2-2, 1.2, 0.8);}
};

Player.prototype.TigerRearLegs = function(engine1X, engine1Y, engine2X, engine2Y, jump, off, sit, up, stand){
    //fill(this.color[0] - 1, this.color[1] - 3, this.color[2] - 2);
    
    if(!sit){
    //Left
    fill(227, 117, 7);
    roundTri(-8 + engine1X - stand, jump + 0 - off + engine1Y - stand * 3, -5 - engine1X - stand * 3, jump + 17 - (off * 3.4) + engine1Y, 2 - engine1X - stand, jump + 7.6 - (off * 2) + engine1Y, 5.6 - off - stand);
    
    fill(227, 117, 7);
    ellipse(-4 + (off * 0.5) - engine1X - stand * 2, jump + 11.2 - (off * 2) + engine1Y * (1.36 - (off * 0.19)), 4.5, 3.2);
    //Right
    fill(227, 117, 7);
    roundTri(8 - engine2X + stand, jump + 0 - off + engine2Y - stand * 3, 5 + engine2X + stand * 3, jump + 17 - (off * 3.4) + engine2Y, -2 + engine2X + stand, jump + 7.6 - (off * 2) + engine2Y, 5.6 - off - stand);
    fill(227, 117, 7);
    
    ellipse(4 - (off * 0.5) + engine2X + stand * 2, jump + 11.2 - (off * 2) + engine2Y * (1.36 - (off * 0.19)), 4.5, 3.2);
    } else {
        fill(227, 117, 7);
        ellipse(6.5 - (sit * 0.8) - up, 20 + (sit * 1) - engine1Y, 7.4 - (sit * 0.4), 5);
        ellipse(-6.5 + (sit * 0.8) + up, 20 + (sit * 1) - engine2Y, 7.4 - (sit * 0.4), 5);}
};

Player.prototype.body = function(engine1, engine2, jump, y, sit, size, y2){
    //Haunches
    //fill(this.color[0]-1, this.color[1]-3, this.color[2]-2);
    fill(255,128,0);
    ellipse(-4 - (y2 * 0.1), 7 + jump + y + (y2 * 1.1) + engine1, 7 + size * 2, 15 + size - y2/2);
    ellipse(4 + (y2 * 0.1), 7 + jump + y + (y2 * 1.1) + engine2, 7 + size * 2, 15 + size - y2/2);
    
    //Body
    //fill(this.color[0], this.color[1], this.color[2]);
    fill(224, 119, 13);
    ellipse(0, 6 + jump + sit + y2, 13 + size, 21 + size * 6 - (y2/3));
    //Body blades
    fill(181, 102, 18);
     beginShape();
    vertex(-5 - (y2 * 0.1)+5, 7 + jump + y + (y2 * 1.1) + engine1-15);
    vertex(-5 - (y2 * 0.1)+4,7 + jump + y + (y2 * 1.1) + engine1+7);
    vertex(-5 - (y2 * 0.1)+5, 7 + jump + y + (y2 * 1.1) + engine1+1);
    vertex(-5 - (y2 * 0.1)+6, 7 + jump + y + (y2 * 1.1) + engine1+7);
    endShape();
};

Player.prototype.tail = function(x1, y1, x2, y2, x3, y3, x4, y4, sit, crawl, up){
    noFill();
    strokeWeight(4 + (sit? 0.5:0) + (up? 0.5: 0));
    if(sit){
        stroke(0, 0, 0, 20);//shadow
        bezier(x1, y1 + 1 - crawl, x2, y2 + 1, x3 + 1, y3 + 1, x4 + 1, y4 + 9);}
    stroke(this.color[0] + 8 + (sit? 1:0) + (up? 1:0), this.color[1] + 9 + (sit? 1:0) + (up? 1:0), this.color[2] + 8 + (sit? 1:0) + (up? 1:0));
   
    strokeWeight(4 + (sit? 0.5:0) + (up? 0.5: 0));
    stroke(201,104,0);
    bezier(x1, y1 - crawl + up, x2, y2 - crawl + up*2, x3, y3 - crawl + up*2, x4, y4 - crawl + up*3);
};

Player.prototype.sit = function(){
    this.reset = 0;
    this.jumpTheta = 0;
    this.movement = {
        engine: 0,
        shadow: [0, 45, 1],
        head: [0, 0, 0, 0, 0, 0, 0, 0],
        ff: [],
        bf: [0, 0, 0, 0, 0, 0, 1, 0, 0],
        body: [0, 0, 0, 8, 6.5, 1, 0],
        tail: [0, 24, 0, 25, -20 + this.taily * 0.1, 27 + this.tailx * 0.008, 21 - this.tailx * 0.1, 28 + this.tailx * 0.007, 1, 0, 0]
    };
};



Player.prototype.draw = function(){
    var m = this.movement;
    pushMatrix();
    translate(this.x, this.y);
    scale(this.size);
    this.engine(m.engine);
    this.shadow(m.shadow[0], m.shadow[1], m.shadow[2]);
    if(this.theta >= PI || !m.ff[7]){
        this.TigerFrontLegs(m.ff[0], m.ff[1], m.ff[2], m.ff[3], m.ff[4], m.ff[5], m.ff[6], m.ff[7]);
    }
    this.head(m.head[0], m.head[1], m.head[2], m.head[3], m.head[4], m.head[5], m.head[6], m.head[7]);
    if(m.ff[7] && (this.theta < PI || this.theta > 1.7*PI)){
        this.TigerFrontLegs(m.ff[0], m.ff[1], m.ff[2], m.ff[3], m.ff[4], m.ff[5], m.ff[6], m.ff[7]);
    }
    this.TigerRearLegs(m.bf[0], m.bf[1], m.bf[2], m.bf[3], m.bf[4], m.bf[5], m.bf[6], m.bf[7], m.bf[8]);
    this.body(m.body[0], m.body[1], m.body[2], m.body[3], m.body[4], m.body[5], m.body[6]);
    
    if(this.flying){
        pushMatrix();
        translate(0, 5);
        scale(1.5);
        this.flap = 4 * sin(2*PI * this.start/0.15*PI);
        stroke(191, 217, 219);
        strokeWeight(2.5);
        noFill();
    
        arc(-8, 0, 12, -5 - this.flap, 0, 0.55*PI - this.flap);//L
        arc(-6, 0, 10, -3 - this.flap, 0, 0.75*PI - (this.flap * 4));//L
        arc(-4, 0, 8, -2 - this.flap, 0, 0.75*PI - (this.flap * 3));//L
        arc(-2, 0, 6, -1 - this.flap, 0, 0.55*PI - (this.flap * 2));//L
    
        arc(8, 0, 12, -5 - this.flap, 0.45*PI, 2*PI - this.flap);//R
        arc(6, 0, 10, -3 - this.flap, 0.2*PI + (this.flap * 4), PI);//R
        arc(4, 0, 8, -2 - this.flap, 0.2*PI + (this.flap * 3), PI);//R
        arc(2, 0, 6, -1 - this.flap, 0.1*PI + (this.flap * 2), PI);//R
        fill(191, 217, 219);
        noStroke();
        ellipse(0, 0, 5, 3);
        if(this.start === 0.15*PI){this.start = 0;}
        this.start++;
        popMatrix();
    }

    
    this.tail(m.tail[0], m.tail[1], m.tail[2], m.tail[3], m.tail[4], m.tail[5], m.tail[6], m.tail[7], m.tail[8], m.tail[9], m.tail[10]);
    popMatrix();
};

var Star = function() {
    this.x = random(1, width);
    this.y = random(1, height);
    this.size = random(1, 3);
    this.drawStar = function() {
        this.twinkle();
    };
    this.starMover = function() {
        this.x -= 0.15;
        if (this.x < 0) {
            this.x = random(400, 800);
        }
    };

    this.twinkle = function() {
        fill(255, 255, 255);
        ellipse(this.x, this.y, this.size, this.size);
    };

};

// DRAW STARS
var stars = [];
for (var i = 0; i < 500; i++) {
    stars.push(new Star());

}


var drawRangeGame = function(x, y) {
    var incAmount = 0.01;
   
        
    
    for (var t = 0; t < incAmount*width; t += incAmount) {         var n = noise(t,t,t);
        var y = map(n, 0, 1, 0, height*1.1);
        stroke(133, 171, 21);
        rect(t*100, height-y-150, 1, y+10);
    }
    for (var t = 0; t < incAmount*width; t += incAmount) {
        var n = noise(t,t);
        var y = map(n, 0, 1, 0, height*1.1);
        stroke(59, 110, 20);
        rect(t*100, height-0.99*y-140, 1, y+80);
    }
    for (var t = 0; t < incAmount*width; t += incAmount) {
        var n = noise(t,t,t);
        stroke(28, 71, 6);
        var y = map(n, 0, 1, 0, height*0.7);
        rect(t*100, height-0.97*y-207, 1, y+20);
    }
    
    
    
    /*
    fill(133, 171, 21);
    beginShape();
    vertex(-10+x,100);
    vertex(10+x,80);
    vertex(30+x,73);
    vertex(100+x,70);
    vertex(140+x,100);
    vertex(180+x,70);
    vertex(270+x,90);
    vertex(350+x,95);
    vertex(450+x,100);
    vertex(-10+x,100);
    endShape();
    */
     var x, z, a, b;
    /*if(player.turn){
        var ct = cos(-player.turn * player.turnSpeed);
        var st = sin(-player.turn * player.turnSpeed);
        x = this.velocity.x;
        z = this.velocity.y;
        a = this.acceleration.x;
        b = this.acceleration.y;
        this.velocity.x = ct*x + st*z;
        this.velocity.y = ct*z - st*x;
        this.acceleration.x = ct*a + st*b;
        this.acceleration.y = ct*b - st*a;
    }*/
    

};


var AnimatedBackground = function() {
    if (night%2===0){

    background(85, 148, 196);}
    else
    {background(33, 35, 38);
        
    for (var j = 0; j < stars.length; j++) {
        stars[j].starMover();
        stars[j].drawStar();
    }}
};



//Create Floor
var Node = function(position){
    this.position = position.get();  
};
Grid.prototype.findNodes = function(nodes, target){
    for (var n in nodes) {
        if (nodes[n].position.x === target.position.x &&                   nodes[n].position.y === target.position.y &&                   nodes[n].position.z === target.position.z) {
                return n;}
    }
    return false;
};
Grid.prototype.addFace = function(object, nodes, colour){
    var corners = [];
    var i;
    for (var n in nodes) {
        i = this.findNodes(object.nodes, nodes[n]);
        if (i === false) {
            object.nodes.push(nodes[n]);
            i = object.nodes.length - 1;}
        corners.push(i);}
    object.colours.push(colour);
    object.faces.push(corners);
};
Grid.prototype.createFloor = function(x, y, z, w, rows) {
    var building = {
        nodes: [],
        faces: [],
        colours: [],};
    var colour;
    for (var i = 0; i <= this.rows; i ++) {
        for (var j = 0; j <= this.columns; j ++) {
            if ((i/2 - j) % 2) {colour = true;} 
            else {colour = false;}
            var n1 = new PVector(x + j * w, y, z - i * w);
            var n2 = new PVector(x + (j+1) * w, y, z - i * w);
            var n3 = new PVector(x + (j+1) * w, y, z - (i+1) * w);
            var n4 = new PVector(x + j * w, y, z - (i+1) * w);
            this.addFace(building, [new Node(n1), new Node(n2), new Node(n3), new Node(n4)], colour);}
    }
    return building;
};
var building = grid.createFloor(0, player.height + grid.horizon, 0, grid.tileWidth);

Grid.prototype.draw = function(){
    var faces = [];
    var obj = building;
    var nodes = obj.nodes;
    for (var f in obj.faces) {
        var face = obj.faces[f];
        var col = obj.colours[f];
        var fnodes = [];
        var valid = true;
        for (var n in face) {
            var z = nodes[face[n]].position.z;
            var p = this.persp / (this.persp - player.zStart - z);
            if (p > 0) {
                var x = nodes[face[n]].position.x;
                var y = nodes[face[n]].position.y;
                fnodes.push([p * x, p * y - this.horizon, p]);
            } else {
                valid = false;
                break;}
        }
        if (valid) {
            var meanZ = nodes[face[0]].position.z + nodes[face[2]].position.z - 0.20 * (abs(fnodes[0][0]) + abs(fnodes[2][0]));
            faces.push([meanZ, fnodes, col]);}
    }
    faces.sort(function(a, b){
        var x = player.position.z;
        return (x-a[0]) - (x-b[0]);});
    for (var f in faces) {
        var face = faces[f];
        var nodes = face[1];
        noStroke();
        if(face[2]){
            noStroke();
            fill(lerpColor(color(this.colorDk[0], this.colorDk[1], this.colorDk[2]), color(20, 20, 20, 20), map(f, 0, this.visibility, 0, 1)));
            //stroke(lerpColor(color(this.colorLt[0] - 10, this.colorLt[1] - 10, this.colorLt[2] - 10, 255), color(80, 80, 80, 30), map(f, 0, this.visibility * 1, 0, 1)));
        } else {
            noStroke();
            fill(lerpColor(color(this.colorLt[0], this.colorLt[1], this.colorLt[2]), color(80, 80, 80, 30), map(f, 0, this.visibility * 1, 0, 1)));
            //stroke(lerpColor(color(this.colorLt[0] - 10, this.colorLt[1] - 10, this.colorLt[2] - 10, 255), color(80, 80, 80, 30), map(f, 0, this.visibility * 1, 0, 1)));
        }
        if(f <= this.visibility){
            if(nodes[0][2] < 1){
                strokeWeight(2 * nodes[0][2]);
            } else {strokeWeight(0);}
            quad(nodes[0][0], nodes[0][1],
                nodes[1][0], nodes[1][1],
                nodes[2][0], nodes[2][1],
                nodes[3][0], nodes[3][1]);}
    } 
};


//Set Tiger Movement Variables...
Player.prototype.trot = function(){
    this.reset = 0;
    this.jumpTheta = 0;
    this.movement = {
        engine: this.theta * 2,
        shadow: [0, 30],
        ff: [this.dotXL * 0.025, this.dotX * 0.025, 1.4, 18, 0, 25, 0, 0],
        head: [this.dotX * 0.007, 0, -1.5, 0, 2, 3, 0, 0],
        bf: [this.dotXL * 0.001, this.dotXL * 0.021, this.dotX * 0.001, this.dotX * 0.021, 0, 0, 0, 0, 0],
        body: [this.dotXL * 0.004, this.dotX * 0.004, 0, 0, 0, 0, 0],
        tail: [1 - this.dotX * 0.004, 0, this.dotXL * 0.003 - 1, -4, this.taily * 0.1 - 20, this.tailx * 0.007 - 9, 21 - this.tailx * 0.1, this.tailx * 0.007 - 13, 0, 0, 0]
    };
};

Player.prototype.jump = function(){
    var jump = true;
    var shdw;
    if(this.reset === 0){
        this.y2 = 0;
        this.jumpTheta = 0;
        this.reset = 1;}
    this.y2 += (-(this.dotY - 200) * (this.speed * this.jumper));
    if(this.reset === 2){
        var jump = false;
        this.y2 = 0;
        this.y2 += (-(this.dotY - 200) * (this.speed * (this.jumper/2)));
        this.reset = 0;}
        
    if(!jump){
        shdw = [0, 30];
    } else {
        shdw = [this.dotX * 0.01 - 3, this.dotX/8];
    }
        
    this.movement = {
        engine: this.jumpTheta * 2,
        shadow: shdw,
        head:[0, this.y2 - this.dotX *0.007, 0, 1, 2, 3, 0, 0],
        ff: [this.dotXF * 0.025, this.dotXF * 0.025, 2.4, 17, this.y2, 25, 0, 0],
        bf:[this.dotX * 0.004, this.dotX * 0.029, this.dotX * 0.004, this.dotX * 0.029, this.y2, 1, 0, 0, 0],
        body:[this.dotX * 0.011, this.dotX * 0.011, this.y2, -2, 0, 0, 0],
        tail: [0, this.y2 - 3 + this.dotX * 0.015, 0, this.y2 - 5, this.taily * 0.1 - 20, this.y2 - 9 + this.tailx * 0.008, 21 - this.tailx * 0.1, this.y2 - 13 + this.tailx * 0.007, 0, 0, 0]
    };
};

Player.prototype.stand = function(){
    this.reset = 0;
    this.jumpTheta = 0;
    this.movement = {
        engine: 0,
        shadow: [0, 30],
        head: [1, -2, -1.1, 0, 2, 3, 0, 0],
        ff: [1, 1, 2, 16.2, 0, 25, 1, 0],
        bf: [1, 6, 1, 6, 1, 0, 0, 0, 0.5],
        body: [1, 1, 0, 0, 0, 0, 0],
        tail: [0, 0, this.dotXL * 0.003 - 1, -4, this.taily * 0.1 - 20, this.tailx * 0.007 - 9, 21 - this.tailx * 0.1, this.tailx * 0.007 - 13, 0, 0, 0]
    };
};


Player.prototype.stalk = function(){
    this.reset = 0;
    this.jumpTheta = 0;
    this.movement = {
        engine: this.theta,
        shadow: [-1, 40],
        ff: [this.dotXL * 0.05, this.dotX * 0.025, 7, 15.5, 0, 18, 1, 0],
        head: [this.dotX * 0.007, 0, -1.5, 0, 1, 3, 7, 0],
        bf: [this.dotXL * 0.001, this.dotXL * 0.021, this.dotX * 0.001, this.dotX * 0.021, 0, 0, 3, 0, 0],
        body: [this.dotXL * 0.005, this.dotX * 0.005, 0, 0, 1, 0.1, 5],
        tail: [1 - this.dotX * 0.004, 24, 0, 25, -20 + this.taily * 0.1, 27, 21 - this.tailx * 0.1, 28, 1, 6, 0]
    };
};


Player.prototype.pounce = function(){
    if(this.reset === 0){
        this.y2 = 0;
        this.jumpTheta = 0;
        this.theta = 0;
        this.reset = 2;}
    this.y2 += ((200 - this.dotY) * this.speed * 0.0008);
    this.movement = {
        engine: this.jumpTheta * 2,
        shadow: [this.dotX * 0.01 - 3, this.dotX/8],
        ff: [this.dotXF * 0.02, this.dotXF * 0.02, 8.4 - this.dotXF * 0.02, 16 + this.y2, this.y2 *1.2, 25, 1, 0],
        head: [0, this.y2 + this.dotX *0.01 + 2, 0, 0.9, 2, 3, 0, 0],
        bf: [this.dotX * 0.001, this.y2/2 + this.dotXL * 0.05, this.dotX * 0.001, this.y2/2 + this.dotXL * 0.05, 0, 0, 3, 0.5, 0],
        body: [-this.dotX * 0.005 + 5, -this.dotX * 0.005 + 5, this.y2 + 1, -2, 1, 0, 4],
        tail: [0, this.y2 + 10 + this.dotX * 0.005, -8, this.y2 + 3, 8 + this.taily * 0.00, this.y2 + this.tailx * 0.00 + 5, 1 - this.tailx * 0.00, this.y2 * 2 + this.tailx * 0.00 - 3, 0, 6, 20 - this.taily * 0.05]
    };
};


var Rabbit = function(x, z, speed){
    this.size = 0.3;
    this.position = new PVector(x, ((124 - this.size/2) + grid.horizon * 0.675), z);
    this.velocity = new PVector();
    this.topspeed = speed;
    this.speed = speed;
    this.color = [120, 120, 120];
    if(speed > 5){
        this.color = [90, 80, 70];}
    this.coord = new PVector(x, -z);
    this.acceleration = new PVector();
    this.v = new PVector();
};
//Create Rabbits
var totalRabbits = 30;
var rabbits = [];
for(var i = 0; i < totalRabbits * 5/6; i++){
    rabbits.push(new Rabbit(random(1000, 3000), random(-500, -2000), 0.0001));
}
for(var j = 0; j < totalRabbits/6; j++){
    rabbits.push(new Rabbit(random(1000, 3000), random(-500, -2000), 0.0005));
}

//Create Rabbits Functions
Rabbit.prototype.rotate = function(angle){
    this.moveX = 70 * cos(angle + 0.5*PI);
    this.moveY = 40 * sin(angle + 0.5*PI);
    this.moveX0 = 80 * cos(angle);
    this.moveY0 = 60 * sin(angle);
    this.moveX180 = 80 * cos(angle + PI);
    this.moveY180 = 60 * sin(angle + PI);
    this.moveX270 = 80 * cos(angle + 1.5*PI);
    this.moveY270 = 40 * sin(angle + 1.5*PI);
};

Rabbit.prototype.update = function(){
    this.scatter();
    
    this.acceleration = PVector.random2D();
    this.acceleration.mult(random(-this.speed/5, this.speed/5));
    
    this.angle = atan2(-this.velocity.y, this.velocity.x);
    this.angle -= 0.5*PI;
    if(this.angle > 1.99*PI){
        this.angle -= 2*PI;
    } else if (this.angle < 0){
        this.angle += 2*PI;}
    
    this.checkEdge();
    
    var x, z, a, b;
    if(player.turn){
        var ct = cos(-player.turn * player.turnSpeed);
        var st = sin(-player.turn * player.turnSpeed);
        x = this.velocity.x;
        z = this.velocity.y;
        a = this.acceleration.x;
        b = this.acceleration.y;
        this.velocity.x = ct*x + st*z;
        this.velocity.y = ct*z - st*x;
        this.acceleration.x = ct*a + st*b;
        this.acceleration.y = ct*b - st*a;
    }
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.topspeed);
    this.position.x += this.velocity.x;
    this.position.z -= this.velocity.y;
    
    this.v.x = this.velocity.x * cos(player.angle) + this.velocity.y * sin(player.angle);
    this.v.y = this.velocity.y * cos(player.angle) - this.velocity.x * sin(player.angle);
    this.coord.x += this.v.x;
    this.coord.y += this.v.y;
};

Rabbit.prototype.checkEdge = function(){
    var buffer = 20;
    var sw = buffer;
    var n = (grid.rows + 1) * grid.tileWidth - buffer;
    var e = (grid.columns + 1) * grid.tileWidth - buffer;
    var nextX = this.velocity.x * cos(player.angle) + this.velocity.y * sin(player.angle);
    var nextY = this.velocity.y * cos(player.angle) - this.velocity.x * sin(player.angle);
    
    if(this.coord.x + nextX < sw || this.coord.x + nextX > e || this.coord.y + nextY < sw || this.coord.y + nextY > n){
        this.acceleration.mult(-1);
        this.velocity.mult(-1);
    }
};

Rabbit.prototype.scatter = function(){
    if((abs(this.position.x) < grid.tileWidth/2 && abs(this.position.z) < grid.tileWidth * 1.2 && !player.hunting) || (abs(this.position.x) < 60 && abs(this.position.z) < 60 && abs(this.position.x) >= 40 && abs(this.position.z) >= 40)){
        var Tiger = new PVector(0, 0);
        var run = PVector.sub(this.position, Tiger);
        run.normalize();
        run.mult(30);
        this.topspeed = -3 + player.speed;
        this.velocity.set(run);
    } else if (abs(this.position.x) > grid.tileWidth * 3.5 || abs(this.position.z) > grid.tileWidth * 4 && this.topspeed === (-3 + player.speed)){
        this.velocity.normalize();
        this.topspeed = this.speed;
    }
};

Rabbit.prototype.draw = function(){
    var z = this.position.z;
    var p = grid.persp / (grid.persp - player.zStart - z);
    var a = 255 + z/(grid.tileWidth/10);
    pushMatrix();
    translate(p * this.position.x, p * this.position.y - grid.horizon);
    scale(this.size * p);
    this.rotate(this.angle);
    
    noStroke();
    
    if(this.angle >= 1.4*PI || this.angle <= 0.6*PI){
        fill(this.color[0] - 10, this.color[1] - 10, this.color[2] - 10, a);
    //tail
    fill(255, 255, 255);
   ellipse(-this.moveX*0.5, -20, 40, 40);
    }
    
    fill(this.color[0], this.color[1], this.color[2], a);
    fill(242, 237, 242);
    //body
    ellipse(0, 0, 100, 90 * 0.8);
    
    //head
    ellipse(this.moveX * 0.6, this.moveY * 1.1 - 3, 60, 50);
    
    fill(this.color[0] - 70, this.color[1] - 70, this.color[2] - 70, a);
    fill(207, 118, 118);
    //nose
    ellipse(this.moveX * 0.9, this.moveY * 1.1 - 3, 10, 10);
    
    //eyes
    var i, j;
    if(this.angle < 1.8*PI && this.angle > 0.9*PI){
    j = 0;} else {j = 5;}
    if(this.angle > 0.16*PI && this.angle < 1.1*PI){
        i = 0;} else {i = 5;}
    ellipse(this.moveX * 0.7 - this.moveY/3, this.moveY * 0.75 - 5, i, i);
    ellipse(this.moveX * 0.7 + this.moveY/3, this.moveY * 0.75 - 5, j, j);
    
    //ears
    var c, f, s;
    if(this.angle > 0.5*PI && this.angle < 1.5*PI){
        fill(this.color[0], this.color[1], this.color[2], a);
        fill(242, 179, 179);
    } else {
        fill(this.color[0] + 30, this.color[1] + 20, this.color[2] + 20, a);}
        fill(224, 191, 177,200);
        strokeWeight(15);
    stroke(this.color[0], this.color[1], this.color[2], a);
    stroke(255, 255, 255);
    strokeWeight(10);
    ellipse(this.moveX * 0.5 - this.moveY/2.5, this.moveY * 0.5 - 40, this.moveX0/3, 100);
    ellipse(this.moveX * 0.5 + this.moveY/2.5, this.moveY * 0.5 - 40, this.moveX0/3, 100);
    
    noStroke();
    fill(this.color[0], this.color[1], this.color[2], a);
    fill(255, 255, 255);
    //forehead
    arc(this.moveX/1.7, this.moveY * 0.5, 10 + this.moveY, 40 - this.moveY * 0.1, 180, 360);
    
    if(this.angle <= 0.6*PI || this.angle >= 1.4*PI){
        fill(this.color[0] - 70, this.color[1] - 70, this.color[2] - 70, a);
        //eyes
        if(this.angle < 1.7*PI && this.angle > 0.9*PI){
        j = 0;} else {j = 5;}
        if(this.angle > PI/4 && this.angle < 1.1*PI){
            i = 0;} else {i = 5;}
        ellipse(this.moveX * 0.7 - this.moveY/3, this.moveY * 0.75 - 5, i, i);
        ellipse(this.moveX * 0.7 + this.moveY/3, this.moveY * 0.75 - 5, j, j);}
    if(this.angle > 0.55*PI && this.angle < 1.45*PI){
        fill(this.color[0] - 10, this.color[1] - 10, this.color[2] - 10, a);
    //tail
    fill(255, 255, 255);
    ellipse(-this.moveX*0.5, -20, 40, 40);
    }
    popMatrix();
};

//Create Grid Movements
var moveGrid = function(x, y, z){
    var move = new PVector(x, y, z);
    var nodes = building.nodes;
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].position.add(move);}
    for(var b in rabbits){
        rabbits[b].position.add(move);}        
};
Player.prototype.move = function(x, z){
    if(x === "wallride"){
        var angle = this.wall[0];
        var wall = this.wall[1];
        x = cos(angle) * this.speed * sin(angle);
        z = sin(angle) * this.speed * sin(angle);
        var offset = this.speed * sin(angle);
        if(wall === PI){this.position.x -= offset;}
        if(wall === 0 || wall === 2*PI){this.position.x += offset;}
        if(wall === 1.5*PI){this.position.z += offset;}
        if(wall === 0.5*PI){this.position.z -= offset;}
    } else {
        var velocity = new PVector(z * sin(this.angle), 0, z * cos(this.angle));
        this.position.add(velocity);}
    moveGrid(-x, 0, z);
};
player.move(player.position.x, 100);

Player.prototype.bounce = function(gravity){
    var y;
    if (this.position.y || this.jumping) {
        if (this.position.y + this.jumping < 0) {
            this.jumping = -this.position.y;}
        y = this.jumping;
        this.position.y += y;}
    moveGrid(0, y, 0);
    if(this.position.y || this.jumping){
        this.jumping -= gravity;}
};

Player.prototype.rotate = function(){
    if(this.turn){
        var ct = cos(this.turn * this.turnSpeed);
        var st = sin(this.turn * this.turnSpeed);
        var x, y, z;
        var nodes = building.nodes;
        for (var i = 0; i < nodes.length; i+=1) {
                x = nodes[i].position.x;
                //y = nodes[i][1];
                z = nodes[i].position.z;
                nodes[i].position.x = ct*x + st*z;
                nodes[i].position.z = ct*z - st*x;}
        for(var b in rabbits){
            x = rabbits[b].position.x;
            z = rabbits[b].position.z;
            rabbits[b].position.x = ct*x + st*z;
            rabbits[b].position.z = ct*z - st*x;}
            
        this.angle += (this.turn * this.turnSpeed);
        if(this.angle > 2*PI - this.turnSpeed){
            this.angle = 0;
        } else if(this.angle < 0){
            this.angle = 2*PI - this.turnSpeed;}
    }
};

//Rabbit Tally
var rabbitCaught = function(x, y){
    pushMatrix();
    translate(x, y);
    scale(0.7);
    stroke(232, 232, 232);
    strokeWeight(1);
    fill(247, 242, 247);
    ellipse(0, +5, 26, 40);
    ellipse(-8, -15, 13, 30);
    ellipse(8, -15, 13, 30);
    fill(207, 170, 195);
    ellipse(0, 20, 7, 7);
    stroke(84, 72, 72);
    strokeWeight(2);
    line(-10, 10, -5, 5);
    line(-5, 10, -10, 5);
    line(5, 10, 10, 5);
    line(10, 10, 5, 5);
    popMatrix();
};

//Collision Detection for Edges
var cSort = function(a, b){return a-b;};
var buffer = 0.16*PI;
var wSW = buffer;
var wN = (grid.rows + 1) * grid.tileWidth - buffer;
var wE = (grid.columns + 1) * grid.tileWidth - buffer; 

Player.prototype.blocked = function(){
    if(this.position.x > wSW && this.position.x < wE && this.position.z > wSW && this.position.z < wN){
        this.wall = [];
        return false;}
    var normAng = this.getWall();
    if(normAng[0] === "corner"){
        var corner = [normAng[1], normAng[2]];
        corner.sort(cSort);
        if(this.facingCorner(corner)){return true;}
        if(!this.facingCorner(corner) && this.corner === 999){return false;}
        normAng = this.corner;}
    if (!this.facingWall(normAng[0])) {
        return false;}
    return true;
};


Player.prototype.getWall = function(){
    var wallNorm = [];
    var north = abs(this.position.z - wN);
    var south = abs(this.position.z - wSW);
    var west = abs(this.position.x - wSW);
    var east = abs(this.position.x - wE);
    var walls = [north, south, east, west];
    walls.sort(cSort);
    for(var i = 0; i < 2; i++){
        if(walls[i] === north && this.angle > 0.5*PI){
            wallNorm[i] = 2*PI;}
        if(walls[i] === north && this.angle <= 0.5*PI){
            wallNorm[i] = 0;}
        if(walls[i] === south){
            wallNorm[i] = PI;}
        if(walls[i] === west){
            wallNorm[i] = 1.5*PI;}
        if(walls[i] === east){
            wallNorm[i] = 0.5*PI;}
    }
    if(walls[0] <= buffer && walls[1] <= buffer){
        return ["corner", wallNorm[0], wallNorm[1]];}
    return [wallNorm[0]];
};

Player.prototype.facingCorner = function(corner){
    var angle = this.angle;
    if(corner[1] - corner[0] > 0.5*PI){//to fix 0/360 wrap
        if(corner[0] === 0){corner[0] = 2*PI;}
        if(corner[1] === 2*PI){corner[1] = 0;}
        corner.sort(cSort);
        if(angle >= corner[0] && angle < corner[1]){
            this.wall = [];
            return true;}//facing corner
        if(corner[0] === 0){corner[0] = 2*PI;}
        if(corner[1] === 2*PI){corner[1] = 0;}
        if(angle < corner[0] && angle > corner[0] - 0.5*PI){
            this.corner = [corner[0]];//facing one wall
        } else if(angle >= corner[1] && angle < corner[1] + 0.5*PI){
            this.corner = corner[1];//facing other wall
        } else {this.corner = 999;}//facing away from corner
        return false;}
    if((angle >= corner[0] && angle <= corner[1]) || angle === 0){
        this.wall = [];
        return true;} //facing corner
    if(angle < corner[0] && angle > corner[0] - 0.5*PI){
        this.corner = [corner[0]];//facing one wall
    } else if(angle > corner[1] && angle < (corner[1] + 0.5*PI)){
        this.corner = [corner[1]];//facing other wall
    } else {this.corner = 999;}//facing away from corner
    return false;
};

Player.prototype.facingWall = function(wallAng){
    var diffAng = this.angle - wallAng;
    if(diffAng <= -0.5*PI || diffAng >= 0.5*PI){
        this.wall = [];
        return false;}
    this.wall = [diffAng, wallAng];
    return true;
};

//Move Player Function
Player.prototype.moveGrid = function(speed){
    if(!this.blocked()){
        this.move(0, speed);
    } else if(this.wall){
        this.move("wallride", speed);}
};


//Set Input Controls
var m, f;
Player.prototype.controls = function(){
    //Jump reset
    if(this.reset === 1){
        if(this.jumpTheta > PI)
        {this.reset = 0;}
    }

    //SHIFT
    if (keyState[SHIFT])
    {this.running = true;} else {this.running = false;}
    
    //S for Jumping
    if ((this.reset === 1 || keyState[83]) && !this.hunting){
        if(!this.position.y){
            this.jumping = 8.5;}
            this.speed = 8;
            this.jumper = 0.0005 * (this.running? 2: 1);
            this.moveGrid(this.speed * (this.running? 3:2));
            this.jump();
    //UP
    } else if (keyState[UP] && !this.hunting) {
        this.fC = 0;
        if(this.speed > 8 && !this.running){
            this.speed -= 0.1;
        } else if(this.running){
            this.speed = 11;
        } else {
            this.speed = 8 + (this.running? 3:0);}
            this.jumper = 0.0005;
            this.moveGrid(this.speed * (this.running? 1.5: 1.1));
            if(this.running){
                this.reset = 2;
                this.jump();
            } else {
                this.trot();}
    } else if (keyState[UP] && this.attack){
        this.pouncing = true;
        f = 10;
        
    //DOWN
    } else if (keyState[DOWN]){
        this.fC = 0;
        this.reset = 0;
        this.jumpTheta = 0;
    //with S 
        if(keyState[83]){
            this.speed = 4;
            this.moveGrid(this.speed * 0.25);
        } else {
            this.speed = 0;}
        this.stalk();
        this.hunting = true;
    //DOWN Released
    } else if(this.hunting){
    //Chase
        if(!this.pouncing){
            this.attack = true;
            this.speed = 7 + (this.running? 10:0);
            this.moveGrid(this.speed);
            this.stalk();
            this.jumpTheta = 0;}
    //Stopped
    } else {
        this.speed = 4;
        this.fC++;
        if(this.fC < 200){
            this.stand();
        } else {
            this.sit();}
    }
    
    //Turn
    if(((keyState[UP] || keyState[83] || this.hunting) && this.speed !== 0) || this.flying){
        if (keyState[LEFT] || keyState[65]){
            this.turnSpeed = 0.02;
            this.turn = -1;
        } else if ((keyState[RIGHT] ||keyState[68])){
            this.turnSpeed = 0.02;
            this.turn = 1;
        } else {this.turn = 0;}
    } else {this.turn = 0;}
    
    //Ongoing
    
    //Pounce
    if(this.pouncing) {
        if(this.rabbits > m){
            fill(255, 255, 0);
            textSize(20);
            text("Roar!", 45, 90);
            if(this.rabbits - m > 1){
                fill(255, 115, 8);
                textSize(36);
                text("COMBO!", -70, -27);
                fill(255, 0, 0);
                text("COMBO!", -70, -30);}
        }
        if(this.attack){
            this.speed = 0;
            this.reset = 0;
            this.theta = 0;
            this.attack = false;}
        if(this.theta < 0.7*PI){
            var tigerStart;
            if(keyState[DOWN]){
            this.flying = true;
            if(keyState[83]){
                moveGrid(0, -10, 0);
                this.position.y -= 10;
            }
            textSize(10);
            fill(0);
            text("SECRET FLYING TIGER MODE!!", -80, -94);
            if(f < 3){
                fill(255, 0, 0);
            } else if (f < 5) {
                fill(255, 255, 0);
            } else {
                fill(255);
            }
            text("SECRET FLYING TIGER MODE!!", -80, -95);
            textSize(20);
            text(f, -30, -70);
            f -= 0.033;
            if(f <= 0){
                keyState[DOWN] = false;
                keyState[UP] = false;
            }
        } else {
            this.flying = false;
        }
            this.jumping = 4;
            this.bounce(4);
            this.moveGrid(14 * (this.running? 1.7:1));
            this.speed = 11;
            this.pounce();
        } else {
            if(this.position.y){
                this.bounce(4);
                this.pounce();
                this.moveGrid(14 * (this.running? 1.7:1));
            } else {
                this.speed = 0;}
            this.fC++;
            if(this.fC > 30){
                this.hunting = false;
                this.pouncing = false;
                this.fC = 0;}
        }
    } else {
        m = this.rabbits;}
    this.rotate();
    if(!this.pouncing){
        this.bounce(0.8);}
    if(this.position.y < 0){
        moveGrid(0, -this.position.y, 0);}
    this.draw();
};



textFont(createFont("aharoni"));


draw = function() {
    
    background(bkgnd[0], bkgnd[1], bkgnd[2]);
    // background(0,0,0);
    
    
    
    
    if (page === "logo") {
        page = "menu";
    }

    //The menu
    else if (page === "menu") {
        textAlign(CENTER, CENTER);
        AnimatedBackground();
        
        //drawCloud();
        if (night%2===0)
        {
            drawSun();
        }
        else
        {
            drawMoon();
        }
         pos+=0.9;
         if(pos > width) {
             
    pos = 0;
    night+=1;
  }
        drawRange(); 
        drawRoad();
        player.speed = 1;
        player.sit();
        player.draw();
         strokeWeight(10);
    stroke(0, 0, 0);

        noStroke();
        //fill(20, 0, 23, 80);
        
strokeWeight(1);
        pushMatrix();
        translate(50, 122);
        if (frameCount % 200 > 100) {
            rotate(textangle2 += 0.0005);
        } else {
            rotate(textangle2 -= 0.0005);
        }
        popMatrix();

        //Dodgeball text
        fill(0, 255, 179);
        textSize(50);
        pushMatrix();
        translate(201, 215);
        if (frameCount % 200 > 100) {
            rotate(textangle += 0.0005);
        } else {
            rotate(textangle -= 0.0005);
        }
        popMatrix();

        //Dodgeball text
        textSize(60);
        pushMatrix();
        translate(201, 170);
        if (frameCount % 200 < 100) {
            rotate(textangle1 -= 0.0005);
        } else {
            rotate(textangle1 += 0.0005);
        }
        stroke(40, 212, 117);
        fill(26, 45, 48,200);
        rect(-width*0.35,-height*0.09,width*0.7,height/5,20);
        fill(0, 221, 255);
        text("The Hunt", 0, 0);
        popMatrix();


        //The Play Button
        stroke(16, 130, 224);
        fill(255, 255, 255, 25);
        if (mouseY <= height/2 && dist(mouseX, mouseY, 140, 45) <= 105) {
            fill(12, 38, 74, 100);
            if (mousePressed) {
                fill(12, 38, 74, 100);
            }
        }
        rect(width/2-60, height/4-70, 120, 73, 25);
        fill(255);
        textSize(30);
        text("Play", width/2, height/4-35);
        //The how to button
        stroke(41, 143, 4);
        fill(255, 255, 255, 25);
        if (mouseY > height/2 && dist(mouseX, mouseY, 140, 275) <= 105) {
            fill(50, 59, 44, 100);
            if (mousePressed) {
                fill(43, 51, 34, 100);
            }
        }
        rect(width/2-60, height*0.75-35, 120, 73, 25);
        fill(255);
        text("How", width/2, height*0.75);
        
        
      
    } else if (page === "game") {
         AnimatedBackground();
        
        //drawCloud();
        if (night%2===0)
        {
            drawSun();
        }
        else
        {
            drawMoon();
        }
         pos+=0.9;
         if(pos > width) {
             
    pos = 0;
    night+=1;
  }
  
  drawRangeGame(mountainposition,0);
        if (keyState[LEFT]){
            mountainposition -= 1 ;
            if (mountainposition === -400)
            {mountainposition = 0;}
        } else if (keyState[RIGHT]){
            mountainposition += 1 ;
            if (mountainposition === 400)
            {mountainposition =0;}
        }
        
        pushMatrix();
    translate(200, 200 - grid.horizon * 0.9);
    
    if(player.y > 25){
        grid.draw();
        
        rabbits.sort(function(a, b){
            return a.position.z - b.position.z;
        });
        for(var b in rabbits){
            rabbits[b].update();
            if(rabbits[b].position.z < 90 && rabbits[b].position.z > -grid.tileWidth * 18){
                rabbits[b].draw();}
        }
        
    }
    
    popMatrix();
        
    if (!player.wins) {
        player.controls();
        
        strokeWeight(1);
        fill(15, 33, 46, 200);
        if (mouseY > 250 && dist(mouseX, mouseY, 23, 335) <= 70) {
            fill(12, 38, 74, 100);}
        
        rect(23, 335, 80, 43, 13);
        textSize(23);
        fill(255, 255, 255);
        text("Menu", 63, 356);
        fill(15, 33, 46, 150);
        rect(-30, -85, 500, 143, 13);
        rabbitCaught(40, 30);
        fill(255);
        textSize(23);
        text("x " + player.rabbits, 80, 30);
        fill(255);
        textSize(23);
        text("Points: " + player.points, 300, 30);
        
        //textSize(10);
        //text(hinder + ", " + hinder2 + " ," + hinder3 + " ," + hinder4, 110, 200);
        
        
    } else {
        stroke(255);
        strokeWeight(20);
        noFill();
        ellipse(0, 150, 1850 - player.y * 20, 1850 - player.y * 20);
        player.flying = false;
        player.speed = 1;
        player.sit();
        fill(bkgnd[0], bkgnd[1], bkgnd[2], 345 - player.y * 3);
        rect(-200, -200 + grid.horizon * 0.9, width, height);
        
        
        
        
        if(player.y > 25){
            player.y--;
        } else {
            player.win();
            textSize(50);
            fill(150, 191, 0);
            text("GOOD TIGER!", -165, -62);
            fill(255, 255, 0);
            text("GOOD TIGER!", -162, -59);
            textSize(30);
            text("You caught ALL the rabbits!", -170, 240);
            fill(255, 153, 0);
            textSize(30);
            text("\t" + player.points + "\n Points!", -160, 0);}
        player.draw();
        
        
    popMatrix();
    
    if(player.pouncing || player.jumping || player.running){
        for(var b in rabbits){
            text("This part is getting run",200,200);
            if(abs(rabbits[b].position.x) < 0 && abs(rabbits[b].position.z) < 60 && player.position.y < rabbits[b].size * 50){
                hinder = abs(rabbits[b].position.x); 
                
                
                hinder2 = abs(rabbits[b].position.z);
                hinder3 = player.position.y;
                hinder4 = rabbits[b].size;
                player.rabbits ++;
                
                
                    player.points += 10;
               
                player.combo = false;
                rabbits.splice(b, 1);
                b--;
                rabbits[b].speed = 0;
            }
        }
    }
    
        
    if(player.rabbits === 1){
        player.wins = true;
    }
        
    }
    

    } else if (page === "how") {

        AnimatedBackground();
        
        //drawCloud();
        drawSun();
        drawRange(); 
        drawRoad();
        player.speed = 1;
        player.sit();
        player.draw();
        fill(15, 33, 46, 200);
        if (mouseY > 250 && dist(mouseX, mouseY, 23, 335) <= 70) {
            fill(12, 38, 74, 100);
            if (mousePressed) {
                fill(12, 38, 74, 100);
                page = "menu";
            }
        }
        rect(23, 335, 80, 43, 13);
        textSize(23);
        fill(255, 255, 255);
        text("Menu", 63, 356);

        //The text
        textSize(45);
        pushMatrix();
        translate(200, 70);
        if (frameCount % 200 > 100) {
            rotate(textangle5 -= 0.0005);
        } else {
            rotate(textangle5 += 0.0005);
        }
        fill(0,0,0,100);
        rect(-width*0.4,-height*0.1,width*0.8,height*0.75,20);
        fill(255, 230, 0);
        text("Instructions\n", 0, 20);
        popMatrix();
        textSize(17);
        pushMatrix();
        translate(200, 140);
        fill(255,255,255);
        text("You are a young tiger learning to Hunt ! \n You make the tiger run, stalk or jump ", 0, -20);
         fill(255,255,255);
        text("There are rabbits out in the field near\n by where you can go hone your skills", 0 , 30);
         fill(255,255,255);
        text("Press [UP] to run, [DOWN] to stalk \n [S] to jump, turn with [<-][->]", 0 , 85);
        fill(255,255,255);
        text("Find all the rabbits to \n complete the game !", 0 , 150);
        popMatrix();

    } 



    noStroke();

};
mouseClicked = function() {

    if (page === "menu") {
        if (mouseY <= 250 && dist(mouseX, mouseY, 140, 45) <= 105) {
            page = "game";
        }
        if (mouseY > 250 && dist(mouseX, mouseY, 140, 275) <= 105) {
            page = "how";
        }}
        
        
        if (page === "how") {
        if (mouseY > 250 && dist(mouseX, mouseY, 23, 335) <= 70) {
            page = "menu";
        }}

           if (page === "game") {
        if (mouseY > 250 && dist(mouseX, mouseY, 23, 335) <= 70) {
            page = "menu";
        }}




};

    }};

    // Get the canvas that Processing-js will use
    var canvas = document.getElementById("mycanvas"); 
    // Pass the function sketchProc (defined in myCode.js) to Processing's constructor.
    var processingInstance = new Processing(canvas, sketchProc); 
 </script>

</html>
